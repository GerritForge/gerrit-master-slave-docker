<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Gerrit Code Review - Prolog Submit Rules Cookbook</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Gerrit Code Review - Prolog Submit Rules Cookbook</h1>
<div class="details">
<span id="revnumber">version v2.13.5-2557-g91ad0fe7b6-dirty</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#SubmitRule">Submit Rule</a></li>
<li><a href="#SubmitType">Submit Type</a></li>
<li><a href="#_prolog_language">Prolog Language</a></li>
<li><a href="#_prolog_in_gerrit">Prolog in Gerrit</a></li>
<li><a href="#_interactive_prolog_cafe_shell">Interactive Prolog Cafe Shell</a></li>
<li><a href="#_swi_prolog">SWI-Prolog</a></li>
<li><a href="#RulesFile">The rules.pl file</a></li>
<li><a href="#HowToWriteSubmitRules">How to write submit rules</a></li>
<li><a href="#SubmitFilter">Submit Filter</a></li>
<li><a href="#HowToWriteSubmitType">How to write submit type</a></li>
<li><a href="#_submit_type_filter">Submit Type Filter</a></li>
<li><a href="#TestingSubmitRules">Testing submit rules</a></li>
<li><a href="#_prolog_vs_gerrit_plugin_for_project_specific_submit_rules">Prolog vs Gerrit plugin for project specific submit rules</a></li>
<li><a href="#_examples_submit_rule">Examples - Submit Rule</a>
<ul class="sectlevel2">
<li><a href="#_example_1_make_every_change_submittable">Example 1: Make every change submittable</a></li>
<li><a href="#_example_2_every_change_submittable_and_voting_in_the_standard_categories_possible">Example 2: Every change submittable and voting in the standard categories possible</a></li>
<li><a href="#_example_3_nothing_is_submittable">Example 3: Nothing is submittable</a></li>
<li><a href="#_example_4_nothing_is_submittable_but_ui_shows_several_need_criteria">Example 4: Nothing is submittable but UI shows several 'Need &#8230;&#8203;' criteria</a></li>
<li><a href="#_example_5_the_need_labels_not_shown_when_change_is_submittable">Example 5: The 'Need &#8230;&#8203;' labels not shown when change is submittable</a></li>
<li><a href="#_example_6_make_change_submittable_if_commit_author_is_john_doe">Example 6: Make change submittable if commit author is "John Doe"</a></li>
<li><a href="#_example_7_make_change_submittable_if_commit_message_starts_with_fix">Example 7: Make change submittable if commit message starts with "Fix "</a></li>
</ul>
</li>
<li><a href="#_the_default_submit_policy">The default submit policy</a>
<ul class="sectlevel2">
<li><a href="#_default_submit_rule_implementation">Default submit rule implementation</a></li>
<li><a href="#_reusing_the_default_submit_policy">Reusing the default submit policy</a></li>
<li><a href="#NonAuthorCodeReview">Example 8: Make change submittable only if <code>Code-Review+2</code> is given by a non author</a></li>
<li><a href="#_example_9_remove_the_code_verified_code_category">Example 9: Remove the <code>Verified</code> category</a></li>
<li><a href="#_example_10_combine_examples_8_and_9">Example 10: Combine examples 8 and 9</a></li>
<li><a href="#_example_11_remove_the_code_verified_code_category_from_all_projects">Example 11: Remove the <code>Verified</code> category from all projects</a></li>
<li><a href="#_example_12_on_release_branches_require_drno_in_addition_to_project_rules">Example 12: On release branches require DrNo in addition to project rules</a></li>
<li><a href="#_example_13_1_1_2_code_review">Example 13: 1+1=2 Code-Review</a></li>
<li><a href="#_example_14_master_and_apprentice">Example 14: Master and apprentice</a></li>
<li><a href="#_example_15_only_allow_author_to_submit_change">Example 15: Only allow Author to submit change</a></li>
</ul>
</li>
<li><a href="#_examples_submit_type">Examples - Submit Type</a>
<ul class="sectlevel2">
<li><a href="#_example_1_set_a_code_cherry_pick_code_submit_type_for_all_changes">Example 1: Set a <code>Cherry Pick</code> submit type for all changes</a></li>
<li><a href="#SubmitTypePerBranch">Example 2: <code>Fast Forward Only</code> for all <code>refs/heads/stable*</code> branches</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="SubmitRule">Submit Rule</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>Submit Rule</em> in Gerrit is logic that defines when a change is submittable.
By default, a change is submittable when it gets at least one
highest vote in each voting category and has no lowest vote (aka veto vote) in
any category.  Typically, this means that a change needs <code>Code-Review+2</code>,
<code>Verified+1</code> and has neither <code>Code-Review-2</code> nor <code>Verified-1</code> to become
submittable.</p>
</div>
<div class="paragraph">
<p>While this rule is a good default, there are projects which need more
flexibility for defining when a change is submittable.  In Gerrit, it is
possible to use Prolog based rules to provide project specific submit rules and
replace the default submit rules. Using Prolog based rules, project owners can
define a set of criteria which must be fulfilled for a change to become
submittable. For a change that is not submittable, the set of needed criteria
is displayed in the Gerrit UI.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Loading and executing Prolog submit rules may be disabled by setting
<code>rules.enable=false</code> in the Gerrit config file (see
<a href="config-gerrit.html#_a_id_rules_a_section_rules">rules section</a>)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://groups.google.com/d/topic/repo-discuss/wJxTGhlHZMM/discussion">This
discussion thread</a> explains why Prolog was chosen for the purpose of writing
project specific submit rules.
<a href="http://gerrit-documentation.googlecode.com/svn/ReleaseNotes/ReleaseNotes-2.2.2.html">Gerrit
2.2.2 ReleaseNotes</a> introduces Prolog support in Gerrit.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="SubmitType">Submit Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>Submit Type</em> is a strategy that is used on submit to integrate the
change into the destination branch. Supported submit types are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Fast Forward Only</code></p>
</li>
<li>
<p><code>Merge If Necessary</code></p>
</li>
<li>
<p><code>Merge Always</code></p>
</li>
<li>
<p><code>Cherry Pick</code></p>
</li>
<li>
<p><code>Rebase If Necessary</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Submit Type</em> is a project global setting. This means that the same submit type
is used for all changes of one project.</p>
</div>
<div class="paragraph">
<p>Projects which need more flexibility in choosing, or enforcing, a submit type
can use Prolog based submit type which replaces the project&#8217;s default submit
type.</p>
</div>
<div class="paragraph">
<p>Prolog based submit type computes a submit type for each change. The computed
submit type is shown on the change screen for each change.</p>
</div>
<div class="paragraph">
<p>When submitting changes in a batch using "Submit including ancestors" or "Submit
whole topic", submit type rules may not be used to mix submit types on a single
branch, and trying to submit such a batch will fail. This avoids potentially
confusing behavior and spurious submit failures. It is recommended to only use
submit type rules to change submit types for an entire branch, which avoids this
situation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prolog_language">Prolog Language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document is not a complete Prolog tutorial.
<a href="http://en.wikipedia.org/wiki/Prolog">This Wikipedia page on Prolog</a> is a
good starting point for learning the Prolog language. This document will only
explain some elements of Prolog that are necessary to understand the provided
examples.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prolog_in_gerrit">Prolog in Gerrit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gerrit uses its own <a href="https://gerrit.googlesource.com/prolog-cafe/">fork</a> of the
original <a href="http://kaminari.istc.kobe-u.ac.jp/PrologCafe/">prolog-cafe</a>
project. Gerrit embeds the prolog-cafe library and can interpret Prolog programs
at runtime.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interactive_prolog_cafe_shell">Interactive Prolog Cafe Shell</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For interactive testing and playing with Prolog, Gerrit provides the
<a href="pgm-prolog-shell.html">prolog-shell</a> program which opens an interactive
Prolog interpreter shell.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The interactive shell is just a prolog shell, it does not load
a gerrit server environment and thus is not intended for
<a href="#TestingSubmitRules">testing submit rules</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_swi_prolog">SWI-Prolog</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Instead of using the <a href="pgm-prolog-shell.html">prolog-shell</a> program one can
also use the <a href="http://www.swi-prolog.org/">SWI-Prolog</a> environment. It
provides a better shell interface and a graphical source-level debugger.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="RulesFile">The rules.pl file</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section explains how to create and edit project specific submit rules. How
to actually write the submit rules is explained in the next section.</p>
</div>
<div class="paragraph">
<p>Project specific submit rules are stored in the <code>rules.pl</code> file in the
<code>refs/meta/config</code> branch of that project.  Therefore, we need to fetch and
checkout the <code>refs/meta/config</code> branch in order to create or edit the <code>rules.pl</code>
file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  $ git fetch origin refs/meta/config:config
  $ git checkout config
  ... edit or create the rules.pl file
  $ git add rules.pl
  $ git commit -m "My submit rules"
  $ git push origin HEAD:refs/meta/config</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="HowToWriteSubmitRules">How to write submit rules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whenever Gerrit needs to evaluate submit rules for a change <code>C</code> from project <code>P</code>
it will first initialize the embedded Prolog interpreter by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>consulting a set of facts about the change <code>C</code></p>
</li>
<li>
<p>consulting the <code>rules.pl</code> from the project <code>P</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Conceptually we can imagine that Gerrit adds a set of facts about the change
<code>C</code> on top of the <code>rules.pl</code> file and then consults it. The set of facts about
the change <code>C</code> will look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  :- package gerrit.                                                   <b class="conum">(1)</b>

  commit_author(user(1000000), 'John Doe', 'john.doe@example.com').    <b class="conum">(2)</b>
  commit_committer(user(1000000), 'John Doe', 'john.doe@example.com'). <b class="conum">(3)</b>
  commit_message('Add plugin support to Gerrit').                      <b class="conum">(4)</b>
  ...</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Gerrit will provide its facts in a package named <code>gerrit</code>. This means we
have to use qualified names when writing our code and referencing these facts.
For example: <code>gerrit:commit_author(ID, N, M)</code></p>
</li>
<li>
<p>user ID, full name and email address of the commit author</p>
</li>
<li>
<p>user ID, full name and email address of the commit committer</p>
</li>
<li>
<p>commit message</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A complete set of facts which Gerrit provides about the change is listed in the
<a href="prolog-change-facts.html">Prolog Facts for Gerrit Change</a>.</p>
</div>
<div class="paragraph">
<p>By default, Gerrit will search for a <code>submit_rule/1</code> predicate in the <code>rules.pl</code>
file, evaluate the <code>submit_rule(X)</code> and then inspect the value of <code>X</code> in order
to decide whether the change is submittable or not and also to find the set of
needed criteria for the change to become submittable. This means that Gerrit has
an expectation on the format and value of the result of the <code>submit_rule</code>
predicate which is expected to be a <code>submit</code> term of the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  submit(label(label-name, status) [, label(label-name, status)]*)</pre>
</div>
</div>
<div class="paragraph">
<p>where <code>label-name</code> is usually <code>'Code-Review'</code> or <code>'Verified'</code> but could also
be any other string (see examples below). The <code>status</code> is one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ok(user(ID))</code>. This status is used to tell that this label/category has been
met.</p>
</li>
<li>
<p><code>need(_)</code> is used to tell that this label/category is needed for the change to
become submittable.</p>
</li>
<li>
<p><code>reject(user(ID))</code>. This status is used to tell that this label/category is
blocking submission of the change.</p>
</li>
<li>
<p><code>impossible(_)</code> is used when the logic knows that the change cannot be submitted
as-is. This is meant for cases where the logic requires members of a specific
group to apply a specific label on a change, but no users are in that group.
This is usually caused by misconfiguration of permissions.</p>
</li>
<li>
<p><code>may(_)</code> allows expression of approval categories that are optional, i.e.
could either be set or unset without ever influencing whether the change
could be submitted.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
For a change to be submittable all <code>label</code> terms contained in the returned
<code>submit</code> term must have either <code>ok</code> or <code>may</code> status.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Gerrit will let the Prolog engine continue searching for solutions of
the <code>submit_rule(X)</code> query until it finds the first one where all labels in the
return result have either status <code>ok</code> or <code>may</code> or there are no more solutions.
If a solution where all labels have status <code>ok</code> is found then all previously
found solutions are ignored. Otherwise, all labels names with status <code>need</code>
from all solutions will be displayed in the UI indicating the set of conditions
needed for the change to become submittable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here some examples of possible return values from the <code>submit_rule</code> predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  submit(label('Code-Review', ok(user(ID))))                        <b class="conum">(1)</b>
  submit(label('Code-Review', ok(user(ID))),
      label('Verified', reject(user(ID))))                          <b class="conum">(2)</b>
  submit(label('Author-is-John-Doe', need(_))                       <b class="conum">(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>label <code>'Code-Review'</code> is met. As there are no other labels in the
return result, the change is submittable.</p>
</li>
<li>
<p>label <code>'Verified'</code> is rejected. Change is not submittable.</p>
</li>
<li>
<p>label <code>'Author-is-John-Doe'</code> is needed for the change to become submittable.
Note that this tells nothing about how this criteria will be met. It is up
to the implementer of the <code>submit_rule</code> to return
<code>label('Author-is-John-Doe', ok(user(ID)))</code> when this criteria is met. Most
likely, it will have to match against <code>gerrit:commit_author</code> in order to
check if this criteria is met. This will become clear through the examples
below.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Of course, when implementing the <code>submit_rule</code> we will use the facts about the
change that are already provided by Gerrit.</p>
</div>
<div class="paragraph">
<p>Another aspect of the return result from the <code>submit_rule</code> predicate is that
Gerrit uses it to decide which set of labels to display on the change review
screen for voting. If the return result contains label <code>'ABC'</code> and if the label
<code>'ABC'</code> is <a href="config-labels.html">defined for the project</a> then voting for the
label <code>'ABC'</code> will be displayed. Otherwise, it is not displayed. Note that the
project doesn&#8217;t need a defined label for each label contained in the result of
<code>submit_rule</code> predicate.  For example, the decision whether
<code>'Author-is-John-Doe'</code> label is met will probably not be made by explicit voting
but, instead, by inspecting the facts about the change.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="SubmitFilter">Submit Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another mechanism of changing the default submit rules is to implement the
<code>submit_filter/2</code> predicate. While Gerrit will search for the <code>submit_rule</code> only
in the <code>rules.pl</code> file of the current project, the <code>submit_filter</code> will be
searched for in the <code>rules.pl</code> of all parent projects of the current project,
but not in the <code>rules.pl</code> of the current project. The search will start from the
immediate parent of the current project, then in the parent project of that
project and so on until, and including, the <code>'All-Projects'</code> project.</p>
</div>
<div class="paragraph">
<p>The purpose of the submit filter is, as its name says, to filter the results
of the <code>submit_rule</code>. Therefore, the <code>submit_filter</code> predicate has two
parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  submit_filter(In, Out) :- ...</pre>
</div>
</div>
<div class="paragraph">
<p>Gerrit will invoke <code>submit_filter</code> with the <code>In</code> parameter containing a <code>submit</code>
structure produced by the <code>submit_rule</code> and will take the value of the <code>Out</code>
parameter as the result.</p>
</div>
<div class="paragraph">
<p>The <code>Out</code> value of a <code>submit_filter</code> will become the <code>In</code> value for the
next <code>submit_filter</code> in the parent line. The value of the <code>Out</code> parameter
of the top-most <code>submit_filter</code> is the final result of the submit rule that
is used to decide whether a change is submittable or not.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>submit_filter</code> is a mechanism for Gerrit administrators to implement
and enforce submit rules that would apply to all projects while <code>submit_rule</code> is
a mechanism for project owners to implement project specific submit rules.
However, project owners who own several projects could also make use of
<code>submit_filter</code> by using a common parent project for all their projects and
implementing the <code>submit_filter</code> in this common parent project. This way they
can avoid implementing the same <code>submit_rule</code> in all their projects.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following "drawing" illustrates the order of the invocation and the chaining
of the results of the <code>submit_rule</code> and <code>submit_filter</code> predicates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  All-Projects
  ^   submit_filter(B, S) :- ...  <b class="conum">(4)</b>
  |
  Parent-3
  ^   &lt;no submit filter here&gt;
  |
  Parent-2
  ^   submit_filter(A, B) :- ...  <b class="conum">(3)</b>
  |
  Parent-1
  ^   submit_filter(X, A) :- ...  <b class="conum">(2)</b>
  |
  MyProject
      submit_rule(X) :- ...       <b class="conum">(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>submit_rule</code> of <code>MyProject</code> is invoked first.</p>
</li>
<li>
<p>The result <code>X</code> is filtered through the <code>submit_filter</code> from the <code>Parent-1</code>
project.</p>
</li>
<li>
<p>The result of <code>submit_filter</code> from <code>Parent-1</code> project is filtered by the
<code>submit_filter</code> in the <code>Parent-2</code> project. Since <code>Parent-3</code> project doesn&#8217;t have
a <code>submit_filter</code> it is skipped.</p>
</li>
<li>
<p>The result of <code>submit_filter</code> from <code>Parent-2</code> project is filtered by the
<code>submit_filter</code> in the <code>All-Projects</code> project. The value in <code>S</code> is the final
value of the submit rule evaluation.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If <code>MyProject</code> doesn&#8217;t define its own <code>submit_rule</code> Gerrit will invoke the
default implementation of submit rule that is named <code>gerrit:default_submit</code> and
its result will be filtered as described above.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="HowToWriteSubmitType">How to write submit type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Writing custom submit type logic in Prolog is similar to
<a href="#HowToWriteSubmitRules">writing submit rules</a>. The only difference is that
one has to implement a <code>submit_type</code> predicate (instead of the <code>submit_rule</code>)
and that the return result of the <code>submit_type</code> has to be an atom that
represents one of the supported submit types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fast_forward_only</code></p>
</li>
<li>
<p><code>merge_if_necessary</code></p>
</li>
<li>
<p><code>merge_always</code></p>
</li>
<li>
<p><code>cherry_pick</code></p>
</li>
<li>
<p><code>rebase_if_necessary</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_submit_type_filter">Submit Type Filter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Submit type filter works the same way as the <a href="#SubmitFilter">Submit Filter</a>
where the name of the filter predicate is <code>submit_type_filter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  submit_type_filter(In, Out).</pre>
</div>
</div>
<div class="paragraph">
<p>Gerrit will invoke <code>submit_type_filter</code> with the <code>In</code> parameter containing a
result of the <code>submit_type</code> and will take the value of the <code>Out</code> parameter as
the result.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="TestingSubmitRules">Testing submit rules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The prolog environment running the <code>submit_rule</code> is loaded with state describing
the change that is being evaluated. The easiest way to load this state is to
test your <code>submit_rule</code> against a real change on a running gerrit instance. The
command <a href="cmd-test-submit-rule.html">test-submit rule</a> loads a specific change
and executes the <code>submit_rule</code>. It optionally reads the rule from from <code>stdin</code>
to facilitate easy testing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  $ cat rules.pl | ssh gerrit_srv gerrit test-submit rule I45e080b105a50a625cc8e1fb5b357c0bfabe6d68 -s</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prolog_vs_gerrit_plugin_for_project_specific_submit_rules">Prolog vs Gerrit plugin for project specific submit rules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since version 2.5 Gerrit supports plugins and extension points. A plugin or an
extension point could also be used as another means to provide custom submit
rules. One could ask for a guideline when to use Prolog based submit rules and
when to go for writing a new plugin. Writing a Prolog program is usually much
faster than writing a Gerrit plugin. Prolog based submit rules can be pushed
to a project by project owners while Gerrit plugins could only be installed by
Gerrit administrators. In addition, Prolog based submit rules can be pushed
for review by pushing to <code>refs/for/refs/meta/config</code> branch.</p>
</div>
<div class="paragraph">
<p>On the other hand, Prolog based submit rules get a limited amount of facts about
the change exposed to them. Gerrit plugins get full access to Gerrit internals
and can potentially check more things than Prolog based rules.</p>
</div>
<div class="paragraph">
<p>From version 2.6 Gerrit plugins can contribute Prolog predicates. This way, we
can make use of the plugin provided predicates when writing Prolog based rules.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples_submit_rule">Examples - Submit Rule</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following examples should serve as a cookbook for developing own submit
rules. Some of them are too trivial to be used in production and their only
purpose is to provide step by step introduction and understanding.</p>
</div>
<div class="paragraph">
<p>Some of the examples will implement the <code>submit_rule</code> and some will implement
the <code>submit_filter</code> just to show both possibilities.  Remember that
<code>submit_rule</code> is only invoked from the current project and <code>submit_filter</code> is
invoked from all parent projects. This is the most important fact in deciding
whether to implement <code>submit_rule</code> or <code>submit_filter</code>.</p>
</div>
<div class="sect2">
<h3 id="_example_1_make_every_change_submittable">Example 1: Make every change submittable</h3>
<div class="paragraph">
<p>Let&#8217;s start with a most trivial example where we would make every change
submittable regardless of the votes it has:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(W)) :-
    W = label('Any-Label-Name', ok(user(1000000))).</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case we make no use of facts about the change. We don&#8217;t need it as we
are simply making every change submittable. Note that, in this case, the Gerrit
UI will not show the UI for voting for the standard <code>'Code-Review'</code> and
<code>'Verified'</code> categories as labels with these names are not part of the return
result. The <code>'Any-Label-Name'</code> could really be any string.</p>
</div>
<div class="paragraph">
<p>The <code>user(1000000)</code> represents the user whose account ID is <code>1000000</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Instead of the account ID <code>1000000</code> we could have used any other account ID.
The following examples will use <code>user(ID)</code> instead of <code>user(1000000)</code> because
it is easier to read and doesn&#8217;t suggest that there is anything special with
the account ID <code>1000000</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_example_2_every_change_submittable_and_voting_in_the_standard_categories_possible">Example 2: Every change submittable and voting in the standard categories possible</h3>
<div class="paragraph">
<p>This is continuation of the previous example where, in addition, to making
every change submittable we want to enable voting in the standard
<code>'Code-Review'</code> and <code>'Verified'</code> categories.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(CR, V)) :-
    CR = label('Code-Review', ok(user(ID))),
    V = label('Verified', ok(user(ID))).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since for every change all label statuses are <code>'ok'</code> every change will be
submittable. Voting in the standard labels will be shown in the UI as the
standard label names are included in the return result.</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_3_nothing_is_submittable">Example 3: Nothing is submittable</h3>
<div class="paragraph">
<p>This example shows how to make all changes non-submittable regardless of the
votes they have.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(R)) :-
    R = label('Any-Label-Name', reject(user(ID))).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since for any change we return only one label with status <code>reject</code>, no change
will be submittable. The UI will, however, not indicate what is needed for a
change to become submittable as we return no labels with status <code>need</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_4_nothing_is_submittable_but_ui_shows_several_need_criteria">Example 4: Nothing is submittable but UI shows several 'Need &#8230;&#8203;' criteria</h3>
<div class="paragraph">
<p>In this example no change is submittable but here we show how to present 'Need
&lt;label&gt;' information to the user in the UI.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">% In the UI this will show: Need Any-Label-Name
submit_rule(submit(N)) :-
    N = label('Any-Label-Name', need(_)).

% We could define more "need" labels by adding more rules
submit_rule(submit(N)) :-
    N = label('Another-Label-Name', need(_)).

% or by providing more than one need label in the same rule
submit_rule(submit(NX, NY)) :-
    NX = label('X-Label-Name', need(_)),
    NY = label('Y-Label-Name', need(_)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the UI this will show:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Need Any-Label-Name</code></p>
</li>
<li>
<p><code>Need Another-Label-Name</code></p>
</li>
<li>
<p><code>Need X-Label-Name</code></p>
</li>
<li>
<p><code>Need Y-Label-Name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From the example above we can see a few more things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>comment in Prolog starts with the <code>%</code> character</p>
</li>
<li>
<p>there could be multiple <code>submit_rule</code> predicates. Since Prolog, by default,
tries to find all solutions for a query, the result will be union of all
solutions. Therefore, we see all 4 <code>need</code> labels in the UI.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_example_5_the_need_labels_not_shown_when_change_is_submittable">Example 5: The 'Need &#8230;&#8203;' labels not shown when change is submittable</h3>
<div class="paragraph">
<p>This example shows that, when there is a solution for <code>submit_rule(X)</code> where all
labels have status <code>ok</code> then Gerrit will not show any labels with the <code>need</code>
status from any of the previous <code>submit_rule(X)</code> solutions.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(N)) :-
    N = label('Some-Condition', need(_)).

submit_rule(submit(OK)) :-
    OK = label('Another-Condition', ok(user(ID))).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>'Need Some-Condition'</code> will not be shown in the UI because of the result of
the second rule.</p>
</div>
<div class="paragraph">
<p>The same is valid if the two rules are swapped:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(OK)) :-
    OK = label('Another-Condition', ok(user(ID))).

submit_rule(submit(N)) :-
    N = label('Some-Condition', need(_)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of the first rule will stop search for any further solutions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_6_make_change_submittable_if_commit_author_is_john_doe">Example 6: Make change submittable if commit author is "John Doe"</h3>
<div class="paragraph">
<p>This is the first example where we will use the Prolog facts about a change that
are automatically exposed by Gerrit. Our goal is to make any change submittable
when the commit author is named <code>'John Doe'</code>. In the very first
step let&#8217;s make sure Gerrit UI shows <code>'Need Author-is-John-Doe'</code> in
the UI to clearly indicate to the user what is needed for a change to become
submittable:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Author)) :-
    Author = label('Author-is-John-Doe', need(_)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will show:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Need Author-is-John-Doe</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>in the UI but no change will be submittable yet. Let&#8217;s add another rule:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Author)) :-
    Author = label('Author-is-John-Doe', need(_)).

submit_rule(submit(Author)) :-
    gerrit:commit_author(A, 'John Doe', _),
    Author = label('Author-is-John-Doe', ok(A)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the second rule we return <code>ok</code> status for the <code>'Author-is-John-Doe'</code> label
if there is a <code>commit_author</code> fact where the full name is <code>'John Doe'</code>. If
author of a change is <code>'John Doe'</code> then the second rule will return a solution
where all labels have <code>ok</code> status and the change will become submittable. If
author of a change is not <code>'John Doe'</code> then only the first rule will produce a
solution. The UI will show <code>'Need Author-is-John-Doe'</code> but, as expected, the
change will not be submittable.</p>
</div>
<div class="paragraph">
<p>Instead of checking by full name we could also check by the email address:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Author)) :-
    Author = label('Author-is-John-Doe', need(_)).

submit_rule(submit(Author)) :-
    gerrit:commit_author(A, _, 'john.doe@example.com'),
    Author = label('Author-is-John-Doe', ok(A)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>or by user id (assuming it is <code>1000000</code>):</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Author)) :-
    Author = label('Author-is-John-Doe', need(_)).

submit_rule(submit(Author)) :-
    U = user(1000000),
    gerrit:commit_author(U, _, _),
    Author = label('Author-is-John-Doe', ok(U)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>or by a combination of these 3 attributes:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Author)) :-
    Author = label('Author-is-John-Doe', need(_)).

submit_rule(submit(Author)) :-
    gerrit:commit_author(A, 'John Doe', 'john.doe@example.com'),
    Author = label('Author-is-John-Doe', ok(A)).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_7_make_change_submittable_if_commit_message_starts_with_fix">Example 7: Make change submittable if commit message starts with "Fix "</h3>
<div class="paragraph">
<p>Besides showing how to make use of the commit message text the purpose of this
example is also to show how to match only a part of a string symbol. Similarly
like commit author the commit message is provided as a string symbol which is
an atom in Prolog terms. When working with an atom we could only match against
the whole value. To match only part of a string symbol we have, at least, two
options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>convert the string symbol into a list of characters and then perform
the "classical" list matching</p>
</li>
<li>
<p>use the <code>regex_matches/2</code> or, even more convenient, the
<code>gerrit:commit_message_matches/1</code> predicate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s implement both options:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Fix)) :-
    Fix = label('Commit-Message-starts-with-Fix', need(_)).

submit_rule(submit(Fix)) :-
    gerrit:commit_message(M), name(M, L), starts_with(L, "Fix "),
    gerrit:commit_author(A),
    Fix = label('Commit-Message-starts-with-Fix', ok(A)).

starts_with(L, []).
starts_with([H|T1], [H|T2]) :- starts_with(T1, T2).</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>name/2</code> embedded predicate is used to convert a string symbol into a
list of characters. A string <code>abc</code> is converted into a list of characters <code>[97,
98, 99]</code>.  A double quoted string in Prolog is just a shortcut for creating a
list of characters. <code>"abc"</code> is a shortcut for <code>[97, 98, 99]</code>. This is why we use
double quotes for the <code>"Trivial Fix"</code> in the example above.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>starts_with</code> predicate is self explaining.</p>
</div>
<div class="paragraph">
<p>Using the <code>gerrit:commit_message_matches</code> predicate is probably more efficient:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Fix)) :-
    Fix = label('Commit-Message-starts-with-Fix', need(_)).

submit_rule(submit(Fix)) :-
    gerrit:commit_message_matches('^Fix '),
    gerrit:commit_author(A),
    Fix = label('Commit-Message-starts-with-Fix', ok(A)).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous example could also be written so that it first checks if the commit
message starts with 'Fix '. If true then it sets OK for that category and stops
further backtracking by using the cut <code>!</code> operator:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(Fix)) :-
    gerrit:commit_message_matches('^Fix '),
    gerrit:commit_author(A),
    Fix = label('Commit-Message-starts-with-Fix', ok(A)),
    !.

% Message does not start with 'Fix ' so Fix is needed to submit
submit_rule(submit(Fix)) :-
    Fix = label('Commit-Message-starts-with-Fix', need(_)).</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_default_submit_policy">The default submit policy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All examples until now concentrate on one particular aspect of change data.
However, in real-life scenarios we would rather want to reuse Gerrit&#8217;s default
submit policy and extend/change it for our specific purpose.  This could be
done in one of the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>understand how the default submit policy is implemented and use that as a
template for implementing custom submit rules,</p>
</li>
<li>
<p>invoke the default submit rule implementation and then perform further
actions on its return result.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_default_submit_rule_implementation">Default submit rule implementation</h3>
<div class="paragraph">
<p>The default submit rule with the two default categories, <code>Code-Review</code> and
<code>Verified</code>, can be implemented as:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(V, CR)) :-
    gerrit:max_with_block(-2, 2, 'Code-Review', CR),
    gerrit:max_with_block(-1, 1, 'Verified', V).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once this implementation is understood it can be customized to implement
project specific submit rules. Note, that this implementation hardcodes
the two default categories. Introducing a new category in the database would
require introducing the same category here or a <code>submit_filter</code> in a parent
project would have to care about including the new category in the result of
this <code>submit_rule</code>. On the other side, this example is easy to read and
understand.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reusing_the_default_submit_policy">Reusing the default submit policy</h3>
<div class="paragraph">
<p>To get results of Gerrit&#8217;s default submit policy we use the
<code>gerrit:default_submit</code> predicate.  The <code>gerrit:default_submit(X)</code> includes all
categories from the database.  This means that if we write a submit rule like
this:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(X) :- gerrit:default_submit(X).</code></pre>
</div>
</div>
<div class="paragraph">
<p>it is equivalent to not using <code>rules.pl</code> at all. We just delegate to
default logic. However, once we invoke the <code>gerrit:default_submit(X)</code> we can
perform further actions on the return result <code>X</code> and apply our specific
logic. The following pattern illustrates this technique:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(S) :- gerrit:default_submit(R), project_specific_policy(R, S).

project_specific_policy(R, S) :- ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following examples both styles will be shown.</p>
</div>
</div>
<div class="sect2">
<h3 id="NonAuthorCodeReview">Example 8: Make change submittable only if <code>Code-Review+2</code> is given by a non author</h3>
<div class="paragraph">
<p>In this example we introduce a new label <code>Non-Author-Code-Review</code> and make it
satisfied if there is at least one <code>Code-Review+2</code> from a non author. All other
default policies like the <code>Verified</code> category and vetoing changes still apply.</p>
</div>
<div class="sect3">
<h4 id="_reusing_the_code_gerrit_default_submit_code">Reusing the <code>gerrit:default_submit</code></h4>
<div class="paragraph">
<p>First, we invoke <code>gerrit:default_submit</code> to compute the result for the default
submit policy and then add the <code>Non-Author-Code-Review</code> label to it.  The
<code>Non-Author-Code-Review</code> label is added with status <code>ok</code> if such an approval
exists or with status <code>need</code> if it doesn&#8217;t exist.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(S) :-
    gerrit:default_submit(X),
    X =.. [submit | Ls],
    add_non_author_approval(Ls, R),
    S =.. [submit | R].

add_non_author_approval(S1, S2) :-
    gerrit:commit_author(A),
    gerrit:commit_label(label('Code-Review', 2), R),
    R \= A, !,
    S2 = [label('Non-Author-Code-Review', ok(R)) | S1].
add_non_author_approval(S1, [label('Non-Author-Code-Review', need(_)) | S1]).</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example uses the <code>univ</code> operator <code>=..</code> to "unpack" the result of the
default_submit, which is a structure of the form <code>submit(label('Code-Review',
ok(user(ID))), label('Verified', need(<em>)), &#8230;&#8203;)</code> into a list like <code>[submit,
label('Code-Review', ok(user(ID))), label('Verified', need(</em>)), &#8230;&#8203;]</code>.  Then we
process the tail of the list (the list of labels) as a Prolog list, which is
much easier than processing a structure. In the end we use the same <code>univ</code>
operator to convert the resulting list of labels back into a <code>submit</code> structure
which is expected as a return result. The <code>univ</code> operator works both ways.</p>
</div>
<div class="paragraph">
<p>In <code>add_non_author_approval</code> we use the <code>cut</code> operator <code>!</code> to prevent Prolog
from searching for more solutions once the <code>cut</code> point is reached. This is
important because in the second <code>add_non_author_approval</code> rule we just add the
<code>label('Non-Author-Code-Review', need(_))</code> without first checking that there
is no non author <code>Code-Review+2</code>. The second rule will only be reached
if the <code>cut</code> in the first rule is not reached and it only happens if a
predicate before the <code>cut</code> fails.</p>
</div>
</div>
<div class="sect3">
<h4 id="_don_t_use_code_gerrit_default_submit_code">Don&#8217;t use <code>gerrit:default_submit</code></h4>
<div class="paragraph">
<p>Let&#8217;s implement the same submit rule the other way, without reusing the
<code>gerrit:default_submit</code>:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(CR, V)) :-
    base(CR, V),
    CR = label(_, ok(Reviewer)),
    gerrit:commit_author(Author),
    Author \= Reviewer,
    !.

submit_rule(submit(CR, V, N)) :-
    base(CR, V),
    N = label('Non-Author-Code-Review', need(_)).

base(CR, V) :-
    gerrit:max_with_block(-2, 2, 'Code-Review', CR),
    gerrit:max_with_block(-1, 1, 'Verified', V).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The latter implementation is probably easier to understand and the code looks
cleaner. Note, however, that the latter implementation will always return the
two standard categories only (<code>Code-Review</code> and <code>Verified</code>) even if a new
category has been inserted into the database. To include the new category
the <code>rules.pl</code> would need to be modified or a <code>submit_filter</code> in a parent
project would have to care about including the new category in the result
of this <code>submit_rule</code>.</p>
</div>
<div class="paragraph">
<p>The former example, however, would include any newly added category as it
invokes the <code>gerrit:default_submit</code> and then modifies its result.</p>
</div>
<div class="paragraph">
<p>Which of these two behaviors is desired will always depend on how a particular
Gerrit server is managed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_9_remove_the_code_verified_code_category">Example 9: Remove the <code>Verified</code> category</h3>
<div class="paragraph">
<p>A project has no build and test. It consists of only text files and needs only
code review.  We want to remove the <code>Verified</code> category from this project so
that <code>Code-Review+2</code> is the only criteria for a change to become submittable.
We also want the UI to not show the <code>Verified</code> category in the table with
votes and on the voting screen.</p>
</div>
<div class="paragraph">
<p>This is quite simple without reusing the <code>gerrit:default_submit</code>:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(CR)) :-
    gerrit:max_with_block(-2, 2, 'Code-Review', CR).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementing the same rule by reusing <code>gerrit:default_submit</code> is a bit more complex:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(S) :-
    gerrit:default_submit(X),
    X =.. [submit | Ls],
    remove_verified_category(Ls, R),
    S =.. [submit | R].

remove_verified_category([], []).
remove_verified_category([label('Verified', _) | T], R) :- remove_verified_category(T, R), !.
remove_verified_category([H|T], [H|R]) :- remove_verified_category(T, R).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_10_combine_examples_8_and_9">Example 10: Combine examples 8 and 9</h3>
<div class="paragraph">
<p>In this example we want to both remove the verified and have the four eyes
principle.  This means we want a combination of examples 7 and 8.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(S) :-
    gerrit:default_submit(X),
    X =.. [submit | Ls],
    remove_verified_category(Ls, R1),
    add_non_author_approval(R1, R),
    S =.. [submit | R].</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>remove_verified_category</code> and <code>add_non_author_approval</code> predicates are the
same as defined in the previous two examples.</p>
</div>
<div class="paragraph">
<p>Without reusing the <code>gerrit:default_submit</code> the same example may be implemented
as:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(CR)) :-
    base(CR),
    CR = label(_, ok(Reviewer)),
    gerrit:commit_author(Author),
    Author \= Reviewer,
    !.

submit_rule(submit(CR, N)) :-
    base(CR),
    N = label('Non-Author-Code-Review', need(_)).

base(CR) :-
    gerrit:max_with_block(-2, 2, 'Code-Review', CR).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_11_remove_the_code_verified_code_category_from_all_projects">Example 11: Remove the <code>Verified</code> category from all projects</h3>
<div class="paragraph">
<p>Example 9, implements <code>submit_rule</code> that removes the <code>Verified</code> category from
one project. In this example we do the same but we want to remove the <code>Verified</code>
category from all projects. This means we have to implement <code>submit_filter</code> and
we have to do that in the <code>rules.pl</code> of the <code>All-Projects</code> project.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_filter(In, Out) :-
    In =.. [submit | Ls],
    remove_verified_category(Ls, R),
    Out =.. [submit | R].

remove_verified_category([], []).
remove_verified_category([label('Verified', _) | T], R) :- remove_verified_category(T, R), !.
remove_verified_category([H|T], [H|R]) :- remove_verified_category(T, R).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_12_on_release_branches_require_drno_in_addition_to_project_rules">Example 12: On release branches require DrNo in addition to project rules</h3>
<div class="paragraph">
<p>A new category 'DrNo' is added to the database and is required for release
branches. To mark a branch as a release branch we use
<code>drno('refs/heads/branch')</code>.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">drno('refs/heads/master').
drno('refs/heads/stable-2.3').
drno('refs/heads/stable-2.4').
drno('refs/heads/stable-2.5').
drno('refs/heads/stable-2.5').

submit_filter(In, Out) :-
    gerrit:change_branch(Branch),
    drno(Branch),
    !,
    In =.. [submit | I],
    gerrit:max_with_block(-1, 1, 'DrNo', DrNo),
    Out =.. [submit, DrNo | I].

submit_filter(In, Out) :- In = Out.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_13_1_1_2_code_review">Example 13: 1+1=2 Code-Review</h3>
<div class="paragraph">
<p>In this example we introduce accumulative voting to determine if a change is
submittable or not. We modify the standard <code>Code-Review</code> to be accumulative, and
make the change submittable if the total score is <code>2</code> or higher.</p>
</div>
<div class="paragraph">
<p>The code in this example is very similar to Example 8, with the addition of
<code>findall/3</code> and <code>gerrit:remove_label</code>.</p>
</div>
<div class="paragraph">
<p>The <code>findall/3</code> embedded predicate is used to form a list of all objects that
satisfy a specified Goal. In this example it is used to get a list of all the
<code>Code-Review</code> scores. <code>gerrit:remove_label</code> is a built-in helper that is
implemented similarly to the <code>remove_verified_category</code> as seen in the previous
example.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">sum_list([], 0).
sum_list([H | Rest], Sum) :- sum_list(Rest,Tmp), Sum is H + Tmp.

add_category_min_score(In, Category, Min,  P) :-
    findall(X, gerrit:commit_label(label(Category,X),R),Z),
    sum_list(Z, Sum),
    Sum &gt;= Min, !,
    P = [label(Category,ok(R)) | In].

add_category_min_score(In, Category,Min,P) :-
    P = [label(Category,need(Min)) | In].

submit_rule(S) :-
    gerrit:default_submit(X),
    X =.. [submit | Ls],
    gerrit:remove_label(Ls,label('Code-Review',_),NoCR),
    add_category_min_score(NoCR,'Code-Review', 2, Labels),
    S =.. [submit | Labels].</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementing the same example without using <code>gerrit:default_submit</code>:</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(submit(CR, V)) :-
    sum(2, 'Code-Review', CR),
    gerrit:max_with_block(-1, 1, 'Verified', V).

% Sum the votes in a category. Uses a helper function score/2
% to select out only the score values the given category.
sum(VotesNeeded, Category, label(Category, ok(_))) :-
    findall(Score, score(Category, Score), All),
    sum_list(All, Sum),
    Sum &gt;= VotesNeeded,
    !.
sum(VotesNeeded, Category, label(Category, need(VotesNeeded))).

score(Category, Score) :-
    gerrit:commit_label(label(Category, Score), User).

% Simple Prolog routine to sum a list of integers.
sum_list(List, Sum)   :- sum_list(List, 0, Sum).
sum_list([X|T], Y, S) :- Z is X + Y, sum_list(T, Z, S).
sum_list([], S, S).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_14_master_and_apprentice">Example 14: Master and apprentice</h3>
<div class="paragraph">
<p>The master and apprentice example allow you to specify a user (the <code>master</code>)
that must approve all changes done by another user (the <code>apprentice</code>).</p>
</div>
<div class="paragraph">
<p>The code first checks if the commit author is in the apprentice database.
If the commit is done by an <code>apprentice</code>, it will check if there is a <code>+2</code>
review by the associated <code>master</code>.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">% master_apprentice(Master, Apprentice).
% Extend this with appropriate user-id for your master/apprentice setup.
master_apprentice(user(1000064), user(1000000)).

submit_rule(S) :-
    gerrit:default_submit(In),
    In =.. [submit | Ls],
    add_apprentice_master(Ls, R),
    S =.. [submit | R].

check_master_approval(S1, S2, Master) :-
    gerrit:commit_label(label('Code-Review', 2), R),
    R = Master, !,
    S2 = [label('Master-Approval', ok(R)) | S1].
check_master_approval(S1, [label('Master-Approval', need(_)) | S1], _).

add_apprentice_master(S1, S2) :-
    gerrit:commit_author(Id),
    master_apprentice(Master, Id),
    !,
    check_master_approval(S1, S2, Master).

add_apprentice_master(S, S).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_15_only_allow_author_to_submit_change">Example 15: Only allow Author to submit change</h3>
<div class="paragraph">
<p>This example adds a new needed category <code>Only-Author-Can-Submit</code> for any user
that is not the author of the patch. This effectively blocks all users except
the author from submitting the change. This could result in an impossible
situation if the author does not have permissions for submitting the change.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_rule(S) :-
    gerrit:default_submit(In),
    In =.. [submit | Ls],
    only_allow_author_to_submit(Ls, R),
    S =.. [submit | R].

only_allow_author_to_submit(S, S) :-
    gerrit:commit_author(Id),
    gerrit:current_user(Id),
    !.

only_allow_author_to_submit(S1, [label('Only-Author-Can-Submit', need(_)) | S1]).</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples_submit_type">Examples - Submit Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following examples show how to implement own submit type rules.</p>
</div>
<div class="sect2">
<h3 id="_example_1_set_a_code_cherry_pick_code_submit_type_for_all_changes">Example 1: Set a <code>Cherry Pick</code> submit type for all changes</h3>
<div class="paragraph">
<p>This example sets the <code>Cherry Pick</code> submit type for all changes. It overrides
whatever is set as project default submit type.</p>
</div>
<div class="paragraph">
<p>rules.pl</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_type(cherry_pick).</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="SubmitTypePerBranch">Example 2: <code>Fast Forward Only</code> for all <code>refs/heads/stable*</code> branches</h3>
<div class="paragraph">
<p>For all <code>refs/heads/stable*</code> branches we would like to enforce the <code>Fast
Forward Only</code> submit type. A reason for this decision may be a need to never
break the build in the stable branches.  For all other branches, those not
matching the <code>refs/heads/stable*</code> pattern, we would like to use the project&#8217;s
default submit type as defined on the project settings page.</p>
</div>
<div class="paragraph">
<p><code>rules.pl</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-prolog" data-lang="prolog">submit_type(fast_forward_only) :-
    gerrit:change_branch(B), regex_matches('refs/heads/stable.*', B),
    !.
submit_type(T) :- gerrit:project_default_submit_type(T).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first <code>submit_type</code> predicate defines the <code>Fast Forward Only</code> submit type
for <code>refs/heads/stable.*</code> branches. The second <code>submit_type</code> predicate returns
the project&#8217;s default submit type.</p>
</div>
<hr style="
  height: 2px;
  color: silver;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
">
<div class="paragraph">
<p>Part of <a href="index.html">Gerrit Code Review</a></p>
</div>
<script type="text/javascript">
    decorate(document.getElementsByTagName('h1'));
    decorate(document.getElementsByTagName('h2'));
    decorate(document.getElementsByTagName('h3'));
    decorate(document.getElementsByTagName('h4'));

    var divs = document.getElementsByTagName('div');
    var arr = new Array();
    var excluded = getExcludedIds();
    for(var i = 0; i < divs.length; i++) {
      var d = divs[i];
      var id = d.getAttribute('id');
      if (id != null && !(id in excluded)) {
        arr[arr.length] = d;
      }
    }
    decorate(arr);

    var anchors = document.getElementsByTagName('a');
    arr = new Array();
    for(var i = 0; i < anchors.length; i++) {
      var a = anchors[i];
      // if the anchor has no id there is no target to
      // which we can link
      if (a.getAttribute('id') != null) {
        // if the anchor is empty there is no content which
        // can receive the mouseover event, an empty anchor
        // applies to the element that follows, move the
        // element that follows into the anchor so that there
        // is content which can receive the mouseover event
        if (a.firstChild == null) {
          var next = a.nextSibling;
          if (next != null) {
            next.parentNode.removeChild(next);
            a.appendChild(next);
          }
        }
        arr[arr.length] = a;
      }
    }
    decorate(arr);

    function decorate(e) {
      for(var i = 0; i < e.length; i++) {
        e[i].onmouseover = function (evt) {
          var element = this;
          // do nothing if the link icon is currently showing
          var a = element.firstChild;
          if (a != null && a instanceof Element
              && a.getAttribute('id') == 'LINK') {
            return;
          }

          // if there is no id there is no target to link to
          var id = element.getAttribute('id');
          if (id == null) {
            return;
          }

          // create and show a link icon that links to this element
          a = document.createElement('a');
          a.setAttribute('id', 'LINK');
          a.setAttribute('href', '#' + id);
          a.setAttribute('style', 'position: absolute;'
              + ' left: ' + (element.offsetLeft - 16 - 2 * 4) + 'px;'
              + ' padding-left: 4px; padding-right: 4px;');
          var span = document.createElement('span');
          span.setAttribute('style', 'height: ' + element.offsetHeight + 'px;'
              + ' display: inline-block; vertical-align: baseline;'
              + ' font-size: 16px; text-decoration: none; color: grey;');
          a.appendChild(span);
          var link = document.createTextNode('🔗');
          span.appendChild(link);
          element.insertBefore(a, element.firstChild);

          // remove the link icon when the mouse is moved away,
          // but keep it shown if the mouse is over the element, the link or the icon
          hide = function(evt) {
            if (document.elementFromPoint(evt.clientX, evt.clientY) != element
                && document.elementFromPoint(evt.clientX, evt.clientY) != a
                && document.elementFromPoint(evt.clientX, evt.clientY) != span
                && document.elementFromPoint(evt.clientX, evt.clientY) != link
                && element.contains(a)) {
              element.removeChild(a);
            }
          }
          element.onmouseout = hide;
          a.onmouseout = hide;
          span.onmouseout = hide;
          link.onmouseout = hide;
        }
      }
    }

    function getExcludedIds() {
      var excluded = {};
      excluded['header'] = true;
      excluded['toc'] = true;
      excluded['toctitle'] = true;
      excluded['content'] = true;
      excluded['preamble'] = true;
      excluded['footer'] = true;
      excluded['footer-text'] = true;
      return excluded;
    }
</script>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version v2.13.5-2557-g91ad0fe7b6-dirty<br>
</div>
</div>
<link rel="stylesheet" href="./prettify.min.css">
<script src="./prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>